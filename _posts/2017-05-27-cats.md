---
title:  Learn you a Cats for a number of good reasons
date:   2017-05-27 22:28:00
category: scala
tags: scala cats
published: true
---

So you have heard of _cats_ and you possibly heard of contravariant functors, monad transformers, applicatives and cartesians, and possibly even stumbled upon the term _Kleisli arrows_ and thought "_who needs this?_" Well, you don't _need_ this, but it doesn't hurt to learn a new thing or two. In this article I will show you a few examples of what you can do by just adding the **cats** library to your project's dependencies.



## Monad transformers
In some cases, when a method returns a `F[G[T]]` you could make your life a bit easier by pretending the `T`s are actually in `G` context and the `F` will be _wrapped_ around it eventually. If a method returns `Future[Option[Banana]]`, you could work with a wrapper that is _like_ an Option, but that wrapper is clever enough to not forget, that the Option is in a Future context. Working with `OptionT[Future, Banana]` is at the end of the day almost as natural as working with good old `Option`. I am using OptionT as an example but there are transformers for other monads too. Free of charge, when you use _cats_. **Monad transformers** make life easier when comprehending over nested monads, as you will see in the example below.

Take a look at this code:

{% highlight scala %}
final case class Banana(colour: String)

object FutureOptions {

  def findById(id: Long): Future[Option[Banana]] =
    Future.successful(Some(Banana("yellow")))

  val program = for {
    optBanana <- findById(123L)
  } yield optBanana.map(_.colour)

  def main(args: Array[String]): Unit =
    Await.result(program.map(_.fold(())(println)), Inf)

}
{% endhighlight %}

There are two ugly points in the above code listing: a `map` operation in the `yield` clause of our program's for-comprehension; and another mapping of the final future result in order to make use of it (i.e. to print it). Now let's add _cats_ to our code and we get the following:


{% highlight scala %}
object OptionTs extends FutureInstances {

  def findById(id: Long): OptionT[Future, Banana] =
    OptionT.some(Banana("yellow"))

  val program = for {
    banana <- findById(123L)
  } yield banana.colour

  def main(args: Array[String]): Unit =
    Await.result(program.fold(())(println), Inf)

}
{% endhighlight %}

This code reads more naturally. The _futurity_ of the Option is hidden away from our view. cats' **OptionT** is the clever wrapper that keeps track of the un-nested Future monad. It is able to do so thanks to an instance of `Applicative[Future]` in scope. Where did it come from? Well, in our example we mixed the various cats instances for Future via the `FutureInstances` trait. We could also achieve the same by a more localised import of `cats.instances.future._`

The first cats-free sample required these imports:

{% highlight scala %}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration._
import scala.concurrent.{Await, Future}
{% endhighlight %}

The catified code sample required two additional lines of imports: the `FutureInstances` and the `OptionT` data type itself:


{% highlight scala %}
import cats.data.OptionT
import cats.instances.FutureInstances
{% endhighlight %}


## Parallel Future execution with Cartesians

In a number of my previous posts I have expected you to have _cats_ on your classpath. For example in this article about [parallel evaluation of Futures]({{ site.baseurl }}{% post_url 2017-05-23-concurrent-futures %}) I made good use of some of the constructs provided by _cats_. Namely **Cartesians** and the **Traverse** type class. 

Below is an example of mixing **sequential** _and_ **parallel** execution of `Futures` by using the cats-provided cartesian builder (and the scream operator `|@|`)


{% highlight scala %}
import cats.instances.FutureInstances
import cats.syntax.CartesianSyntax

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration.Inf
import scala.concurrent.{Await, Future}

final case class Profile(iid: String, name: String, age: Int)

object SequentialAndParallelFutures extends CartesianSyntax with FutureInstances {

  def main(args: Array[String]): Unit = {
    val program = for {
      id <- getProfileId("reteP")
      p <- getProfile(id)
      (prefs, balance) <- (getPreferences(p.iid) |@| getBalance(p.iid)).tupled
    } yield println(s"${System.currentTimeMillis()} ${p.name}'s balance is $balance. Preferences: $prefs")
    Await.result(program, Inf)
  }

  val getProfileId: String => Future[String] = in => Future {
    println(s"${System.currentTimeMillis()} getProfileId")
    Thread.sleep(1000)
    in
  }

  val getProfile: String => Future[Profile] = pid => Future {
    println(s"${System.currentTimeMillis()} getProfile")
    Thread.sleep(1000)
    Profile(pid.reverse + pid, pid.reverse, pid.length)
  }

  val getPreferences: String => Future[String] = iid => Future {
    println(s"${System.currentTimeMillis()} getPreferences")
    Thread.sleep(1000)
    iid
  }

  val getBalance: String => Future[Long] = iid => Future {
    println(s"${System.currentTimeMillis()} getBalance")
    Thread.sleep(1000)
    System.currentTimeMillis
  }

}
{% endhighlight %}

Note the times printed in the output. Each operation takes roughly one second to complete. The first two happen one after another, then the calls to `getPreferences` and `getBalance` are triggered in parallel and the final result is logged roughly a second after they both started executing.

{% highlight text %}
1496000914339 getProfileId
1496000915341 getProfile
1496000916346 getPreferences
1496000916346 getBalance
1496000917351 Peter's balance is 1496000917351. Preferences: PeterreteP
{% endhighlight %}

Using the **Applicative** instance provided by cats, and the cartesian syntax we were able to collect the results of concurrently running futures into a tuple, which we can easily deconstruct in the left-hand side of the for-comprehension and use the results in any subsequent operations. Isn't that neat?


## Traversing

Let's say we have a number of places that _will potentially_ (read: "will" -> Future, "potentially" -> Option) produce a value of type `T`. We could list these various places like so:

{% highlight scala %}
List(f1(), f2(), f3())
{% endhighlight %}

which would lead to a List of Future Options of T. What would be perhaps more useful is a Future List of all Ts that we were able to obtain from our various places. Here's how you could go about doing that with the cats library:

{% highlight scala %}
List(f1(), f2(), f3()).sequence.map(_.flatten)
{% endhighlight %}

The full code listing follows. We're using the Traverse **syntax** (methods defined on the traverse type class tacked onto applicable types as extension methods) and cats' instances for List and Future.

{% highlight scala %}
import cats.instances.{FutureInstances, ListInstances}
import cats.syntax.TraverseSyntax

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration.Inf
import scala.concurrent.{Await, Future}

object TraversingAsap extends TraverseSyntax with FutureInstances with ListInstances {

  def f1() = Future {
    Thread.sleep(100)
    println(s"${System.currentTimeMillis()} I return Foo")
    Some("Foo")
  }

  def f2() = Future {
    Thread.sleep(50)
    println(s"${System.currentTimeMillis()} No. Not here")
    None
  }

  def f3() = Future {
    println(s"${System.currentTimeMillis()} I return Bar")
    Some("Bar")
  }

  val program = List(f1(), f2(), f3()).sequence map (_.flatten)

  def main(args: Array[String]): Unit = Await.result(program map println, Inf)

}{% endhighlight %}

**_note_** IntelliJ uses a lightweight presentation compiler and struggles with the `.sequence` syntax. You will see highlighted errors but the application still compiles and runs fine from SBT.

We used `Thread.sleep` in a way that almost guarantees that Bar is computed before anything else, and Foo is obtained last. In the program output, however, the final List is ordered correctly as one would expect:

{% highlight text %}
1496080141824 I return Bar
1496080141876 No. Not here
1496080141927 I return Foo
List(Foo, Bar)
{% endhighlight %}

The Futures in the above example would be submitted to the execution context for evaluation ASAP. If you would like to control _when_ the list of future-value-producing functions starts evaluating, you could create a list of `Function0` values. You would then `traverse` the list of functions with another function that applies them. Like so:

{% highlight scala %}
  val program = List(() => f1(), () => f2(), () => f3()).traverse(_ ()) map (_.flatten)
{% endhighlight %}

## Monadic IF

I have become quite fond of the `ifM` flatMap syntax that cats provides and use it quite extensively. `ifM` extension method appears on any `F[Boolean]` once you've either imported `cats.syntax.flatMap._` or mixed in the `FlatMapSyntax` trait. It's effectively delegating to the `flatMap` operation of the `F` monad, but the **mapping function** that will be used for flatmapping will depend on the boolean value contained in the `F` context. You provide one for `ifTrue` and one for `ifFalse` and then just sit back and watch the show.

I will not go into much depth on this topic, but there's a nice example of `ifM` in action in one of my previous articles: [Conditional flatMap]({{ site.baseurl }}{% post_url 2017-05-20-conditional-flatmap %})  

