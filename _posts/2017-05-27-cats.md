---
title:  Learn you a Cats for a number of good reasons
date:   2017-05-27 22:28:00
category: scala
tags: scala cats

---

So you have heard of _cats_ and you possibly heard of contravariant functors, monad transformers, applicatives and cartesians, and possibly even stumbled upon the term _Kleisli arrows_ and thought "_who needs this?_" Well, you don't _need_ this, but it doesn't hurt to learn a new thing or two. In this article I will show you a few examples of what you can do by just adding the **cats** library to your project's dependencies.



## Monad transformers
In some cases, when a method returns a `F[G[T]]` you could make your life a bit easier by pretending the `T`s are actuallin G context and the F will be _wrapped_ around it eventually. If a method returns `Future[Option[Banana]]`, you could work with a wrapper that is _like_ an Option, but that wrapper needs to be clever enough to not forget, that the Option is in a Future context. These wrappers are called **monad transformers** and they make life easier when comprehending over nested monads.

Take a look at this pseudo-code:

{% highlight scala %}
final case class Banana(colour: String)
def findById(id:Long): Future[Option[Banana]]

for {
  optBanana <- findById(123L)
} yield optBanana.map(_.colour)
{% endhighlight %}



In a number of my previous posts I have expected you to have _cats_ on your classpath. For example in this article about [parallel evaluation of Futures]({{ site.baseurl }}{% post_url 2017-05-23-concurrent-futures %}) I made good use of some of the constructs provided by _cats_. Namely **Cartesians** and the **Traverse** type class. 

Below is an example of mixing **sequential** _and_ **parallel** execution of `Futures` by using the cats-provided cartesian builder (and the scream operator `|@|`)


{% highlight scala %}
import cats.instances.FutureInstances
import cats.syntax.CartesianSyntax

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration.Inf
import scala.concurrent.{Await, Future}

final case class Profile(iid: String, name: String, age: Int)

object SequentialAndParallelFutures extends CartesianSyntax with FutureInstances {

  def main(args: Array[String]): Unit = {
    val program = for {
      id <- getProfileId("reteP")
      p <- getProfile(id)
      (prefs, balance) <- (getPreferences(p.iid) |@| getBalance(p.iid)).tupled
    } yield println(s"${System.currentTimeMillis()} ${p.name}'s balance is $balance. Preferences: $prefs")
    Await.result(program, Inf)
  }

  val getProfileId: String => Future[String] = in => Future {
    println(s"${System.currentTimeMillis()} getProfileId")
    Thread.sleep(1000)
    in
  }

  val getProfile: String => Future[Profile] = pid => Future {
    println(s"${System.currentTimeMillis()} getProfile")
    Thread.sleep(1000)
    Profile(pid.reverse + pid, pid.reverse, pid.length)
  }

  val getPreferences: String => Future[String] = iid => Future {
    println(s"${System.currentTimeMillis()} getPreferences")
    Thread.sleep(1000)
    iid
  }

  val getBalance: String => Future[Long] = iid => Future {
    println(s"${System.currentTimeMillis()} getBalance")
    Thread.sleep(1000)
    System.currentTimeMillis
  }

}
{% endhighlight %}

Note the times printed in the output. Each operation takes roughly one second to complete. The first two happen one after another, then the calls to `getPreferences` and `getBalance` are triggered in parallel and the final result is logged roughly a second after they both started executing.

{% highlight text %}
1496000914339 getProfileId
1496000915341 getProfile
1496000916346 getPreferences
1496000916346 getBalance
1496000917351 Peter's balance is 1496000917351. Preferences: PeterreteP
{% endhighlight %}

Using the **Applicative** instance provided by cats, and the cartesian syntax we were able to collect the results of concurrently running futures into a tuple, which we can easily deconstruct in the left-hand side of the for-comprehension and use the results in any subsequent operations. Isn't that neat?
