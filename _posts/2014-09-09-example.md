---
title:  "Getting functional with Scala"
date:   2017-02-26 21:44:00
categories: intro
---

# Welcome
It's been a while since I set up a blog page. Myriad of neat ~~toys~~ tools have sprung up and looks like blogging is much easier these days than ages ago when I first started with some Java articles on Google's [blogger](http://it-demystified.blogspot.co.uk/).



**Concurrent execution**

> "All things appear and disappear because of the concurrence of causes and conditions. Nothing ever exists entirely alone; everything is in relation to everything else."
> 
> _Gautama Buddha_

**Code**

{% highlight scala %}

package parallelFutures

import cats.Traverse

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration.Inf
import scala.concurrent.{Await, Future}

object ParallelVsSerialExecution {

  private def printer: (List[String]) => Unit = _.foreach(println)

  private def tuplePrinter: (String, String, String) => Unit = {
    case res@_ => res.productIterator.foreach(println)
  }

  def findFruit(fruit: String) = Future {
    println(s"${System.currentTimeMillis()} looking for yummy fruit")
    Thread.sleep(1000)
    s"I found your $fruit"
  }

  def sequentialFuturesWithMonads(): Future[Unit] = {
    for {
      a <- findFruit("apple")
      b <- findFruit("banana")
      c <- findFruit("cherry")
    } yield {
      Seq(a, b, c).foreach(println)
    }
  }

  def parallelFuturesWithTraverse(): Future[Unit] = {
    import cats.instances.future._
    import cats.instances.list._
    import cats.syntax.traverse._
    List("apple", "banana", "cherry") traverse findFruit map printer
  }

  def parallelFuturesWithSequence(): Future[Unit] = {
    import cats.instances.future._
    import cats.instances.list._
    Traverse[List] sequence List(findFruit("apple"), findFruit("banana"), findFruit("cherry")) map printer
  }


  def parallelFuturesWithCartesians(): Future[Unit] = {
    import cats.instances.future._
    import cats.syntax.cartesian._
    findFruit("apple") |@| findFruit("banana") |@| findFruit("cherry") map tuplePrinter
  }

  def main(args: Array[String]): Unit = {
    Await.result(sequentialFuturesWithMonads(), Inf)
    println("\n===\n")
    Await.result(parallelFuturesWithTraverse(), Inf)
    println("\n===\n")
    Await.result(parallelFuturesWithSequence(), Inf)
    println("\n===\n")
    Await.result(parallelFuturesWithCartesians(), Inf)
  }

}

{% endhighlight %}


In the above code listing you can find several ways of performing multiple tasks.
In this article we will focus on performing asynchronous operations in parallel in a way that we can still continue with  processing their results in a **predetermined order**.

The listing does, however, include one exmaple of performing calls sequentially - using the for-comprehension the underlying  monadic `bind` / Scala `flatMap` operation. Using flatMap / for-comprehension the individual calls will be performed sequentially, one after another, which is what we would need if results of an earlier call were required as inputs for subsequent calls. Sometimes we can perform independent operations entirely in parallel and there are different ways to achieve this.

