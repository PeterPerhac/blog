---
title: API call scripting with Scala and Ammonite
description: Ditch your GUI tool (Postman, Advanced REST client, etc) and build your collection of HTTP requests in a language close to your heart - Scala. Script your Web API interactions with sttp.
date:   2018-06-02 17:28:00
category: scala
tags: scala sttp http ammonite
published: false

---

I find **Advanced REST Client** too clunky when it comes to organising requests into collections/projects. **Postman** is much nicer but there's no way I am getting a paid subscription for the ability to share request collections with my colleagues. IntelliJ IDEA (Ultimate edition only) offers a handy but _very_ cumbersome HTTP Client plugin.

Having battled with these three I decided I've had enough of clicking buttons, and working around various limitations - after all I am a Scala developer and can script up any kind of Web API interaction in Scala, provided I find a decent enough library.

Let's take a look at Software Mill's sttp HTTP client library. And while we're at it, let's also take a look at Ammonite REPL - Scala REPL on steroids.



Here's STTP's github page: https://github.com/softwaremill/sttp
Let's have a quick play around with it - install [Ammonite (REPL)](http://ammonite.io/)

```bash
#for mac users with Homebrew
brew install ammonite-repl
```

Fire up Ammonite REPL by typing `amm` and then paste the following code into the console:

{% highlight scala %}
import $ivy.`com.softwaremill.sttp::core:1.2.0-RC2`
import com.softwaremill.sttp._
implicit val backend = HttpURLConnectionBackend()
sttp.get(uri"http://httpbin.org/ip").send()
{% endhighlight %}

You will see the truncated response in the output. Ammonite will truncate output at a certain point, but you can make it show you the whole output by using the predefined `show` function.
i.e. if the result of making the GET call was assigned to res3, you can type `show(res3)` to see the output in its entirety.

You may also want to change the defaults for the REPL pretty-printer like so:

```
repl.pprinter() = repl.pprinter().copy(defaultHeight = 5)
```

## STTP

So we saw the basics, and that was as quick as it gets. Let's dive a little deeper, beyond a basic GET command.



### Original solution

{% highlight scala %}
import scala.concurrent.ExecutionContext.Implicits.global

import cats.instances.future._
import cats.syntax.applicative._
import cats.syntax.flatMap._

for {
  vatEligibility <- viewModel[VatServiceEligibility]
  _ <- s4l.saveForm(vatEligibility.setAnswer(question, data.answer))
  exit = data.answer == question.exitAnswer
  _ <- exit.pure.ifM(keystore.cache(INELIGIBILITY_REASON, question.name), ().pure)
} yield ...
{% endhighlight %}

Let's focus on this line:

{% highlight scala %}
exit.pure.ifM(keystore.cache(INELIGIBILITY_REASON, question.name), ().pure)
{% endhighlight %}

This lifts the boolean condition `exit` into the `Future` context using `.pure` syntax. `pure` method is defined on the `Applicative` type class and if we import `cats.syntax.applicative._` we can lift _any_ value into an effect `F`, provided there is an implicit instance of `Applicative[F]` available in scope. ([Read Eugene's article](http://eed3si9n.com/revisiting-implicits-without-import-tax) to understand how implicits are resolved)

We can make further use of the [cats library][1] to enrich any `Future[Boolean]` (indeed, a boolean in any monadic context) with the `ifM` method. `ifM` is introduced by the import of `cats.syntax.flatMap._` and allows for flatMapping different expressions, depending on what's in the box (i.e. the boolean value in the context, on which we added the `ifM` extension method).

Just like `flatMap` takes a function `A => F[B]`, `ifM` takes **two** functions of this shape, but only flatMaps _one of them_. The first parameter to `ifM` is called `ifTrue` and the second one is `ifFalse` and which one gets flatmapped is obvious. I made the conditional service call in the `ifTrue` part, leaving the `ifFalse` as a successfully completed `Future` of `Unit`.

But when I slept on it and re-visited the line the next day, I thought I would much rather have it written like this:

{% highlight scala %}
  _ <- keystore.cache(INELIGIBILITY_REASON, question.name) onlyIf exit
{% endhighlight %}

### Natural looking DSL

Remember the part about natural looking DSLs? With the help of an implicit class and some cat-herding skills, I was able to make my dream come true:

{% highlight scala %}
implicit class CustomApplicativeOps[F[_], A](fa: => F[A])(implicit F: Applicative[F]) {
  def onlyIf(condition: Boolean): F[Unit] =
    if (condition) F.map(fa)(_ => ()) else F.pure(())
}
{% endhighlight %}


### Final solution
With this implicit class imported into scope, the final for-comprehension looks like this:

{% highlight scala %}
import scala.concurrent.ExecutionContext.Implicits.global

import cats.instances.future._
import cats.syntax.applicative._
import cats.syntax.flatMap._

for {
  vatEligibility <- viewModel[VatServiceEligibility]
  _ <- s4l.saveForm(vatEligibility.setAnswer(question, data.answer))
  exit = data.answer == question.exitAnswer
  _ <- keystore.cache(INELIGIBILITY_REASON, question.name) onlyIf exit
} yield ...
{% endhighlight %}

And that's all, folks.

PS: cats will provide `whenA` syntax from version 1.0. Check it out when it comes out. It can be used to achieve similar sort of thing.

[1]:http://typelevel.org/cats/
